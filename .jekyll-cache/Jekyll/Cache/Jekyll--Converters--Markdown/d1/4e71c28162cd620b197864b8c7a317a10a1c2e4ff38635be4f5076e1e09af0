I"F<h3 id="objectis">Object.is()</h3>
<ul>
  <li>es6에서 새로 추가된 메소드로, Object.is(value1, value2) 식으로 사용하면
value1과 value2가 같은 값인지 형식을 포함해 비교한다.</li>
  <li>’===’와 거의 유사하지만, ‘===’의 단점인 ‘NaN === NaN’가 false라고 
평가되어 isNaN()을 따로 써줘야 했던 점을 보완했다고 한다. (이외에도 +0과 -0을 같은 값으로 취급하지 않는다고 한다.)</li>
  <li>’===’와 마찬가지로 형변환은 일어나지 않는다.
    <blockquote>
      <p>Object.is()는 === 연산자와 똑같이 작동합니다. 유일한 차이점은 +0과 -0이 동등하지 않은 것으로 간주되고 NaN이 NaN과 같은 것으로 간주된다는 것입니다. (mdn)</p>
    </blockquote>
  </li>
</ul>

<h3 id="객체의-in-키워드">객체의 in 키워드</h3>
<ul>
  <li>객체에 특정 속성이나 인덱스가 있는지 확인 할 때, in이라는 키워드를 사용할 수 있다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const user = { name: 'user', email: 'user@example.com' }
name in user // true
1 in user // true

</code></pre></div></div>
<p>객체가 어떤 속성을 갖고있는지 확인할 때 쓰는 메소드로는 Object.hasOwnProperty()만 알고 있었는데, 새롭게 알게 됐다.</p>

<h3 id="hasownproperty-메소드와-in-키워드의-차이점">hasOwnProperty() 메소드와 in 키워드의 차이점</h3>
<ul>
  <li>in 연산자는 <b>프로토타입 체인에 의하여 접근할 수 있는 속성</b>(배열의 length, toString()같이 기본적으로 상속받는 속성 포함)에 대하여 true를 반환한다.</li>
  <li>hasOwnProperty() 메소드는 객체의 프로토타입 체인에서 상속된 프로퍼티를 확인하지는 않는다.</li>
</ul>

<h3 id="for-of와-for-in">for of와 for in</h3>
<ul>
  <li>for .. of
    <ul>
      <li>반복가능한 객체(Array, Map, Set, NodeList)를 순회할 때 사용한다.
        <blockquote>
          <p>for…of 구문은 컬렉션 전용입니다. 모든 객체보다는, [Symbol.iterator] 속성이 있는 모든 컬렉션 요소에 대해 이 방식으로 반복합니다. (mdn)</p>
        </blockquote>
      </li>
    </ul>
  </li>
  <li>for .. in
    <ul>
      <li>객체의 모든 열거가능한 속성에 대해 반복 -&gt; <b>프로토타입에 있는 속성들</b>도 모두 나열된다.</li>
      <li>속도가 느리므로 <b>디버깅용</b>이 아니라면 사용하는 것을 <b>권장하지 않는다</b>.
        <blockquote>
          <p>이것은 쉽게 객체의 속성을 확인(콘솔이나 다른 방법으로 출력)할 수 있기 때문에 실질적으로 디버깅을 위해 사용될 수 있습니다. 배열이 데이터의 저장에 있어서는 더 실용적이지만, 키-값 쌍이 선호되는 데이터의 경우(속성이 “key”의 역할을 함) 특정 값을 가진 키가 있는지 확인하려는 경우에 for…in을 사용할 수 있습니다.
(mdn)</p>
        </blockquote>
      </li>
    </ul>
  </li>
</ul>
:ET